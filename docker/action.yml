name: "Buildx per-arch push + manifest"
description: "Build & push per-arch images with docker buildx; OCI manifest with flexible visibility and tagging"
inputs:
  registry:
    description: "Registry domain (e.g. harbor.slope.es)"
    required: true
  image:
    description: "Bare image name (e.g. slope-graphql)"
    required: true
  visibility:
    description: "Where to tag the manifest: private | public | both"
    required: false
    default: "private"
  dockerfile:
    description: "Path to Dockerfile"
    required: false
    default: "Dockerfile"
  context:
    description: "Build context"
    required: false
    default: "."
  arches:
    description: "Space-separated list of arches"
    required: false
    default: "amd64 arm64"
  build_args:
    description: "Extra build-args (multiline KEY=VALUE). Supports {arch} placeholder."
    required: false
    default: ""
  options:
    description: "Extra options appended to docker buildx build (e.g. --pull --no-cache)"
    required: false
    default: ""
  push:
    description: "Whether to push per-arch images (true/false)"
    required: false
    default: "true"
  manifest:
    description: "Whether to create an OCI manifest from built per-arch images"
    required: false
    default: "true"
  tag:
    description: "Space- or newline-separated list of additional tags for the manifest (e.g. 'latest v0.0.1'). Set empty to disable."
    required: false
    default: "latest"
  verbose:
    description: "Emit detailed logs"
    required: false
    default: "false"
  trace:
    description: "Enable shell tracing (set -x)"
    required: false
    default: "false"

outputs:
  built_tags:
    description: "Newline-separated list of per-arch tags produced"
    value: ${{ steps.run.outputs.built_tags }}

runs:
  using: "composite"
  steps:
    - id: run
      shell: bash
      run: |
        set -euo pipefail

        REGISTRY="${{ inputs.registry }}"
        IMAGE_NAME="${{ inputs.image }}"
        VISIBILITY="${{ inputs.visibility }}"
        DOCKERFILE="${{ inputs.dockerfile }}"
        CONTEXT="${{ inputs.context }}"
        ARCHES="${{ inputs.arches }}"
        BUILD_ARGS_RAW="${{ inputs.build_args }}"
        OPTIONS_RAW="${{ inputs.options }}"
        PUSH="${{ inputs.push }}"
        MAKE_MANIFEST="${{ inputs.manifest }}"
        TAG_RAW="${{ inputs.tag }}"
        VERBOSE="${{ inputs.verbose }}"
        TRACE="${{ inputs.trace }}"

        [ "$TRACE" = "true" ] && set -x || true
        begin(){ [ "$VERBOSE" = "true" ] && echo "::group::$*"; }
        end(){   [ "$VERBOSE" = "true" ] && echo "::endgroup::"; }

        case "$VISIBILITY" in
          private|public|both) ;;
          *) echo "::error::Invalid visibility '$VISIBILITY' (use private|public|both)"; exit 2;;
        esac

        PRIVATE_IMAGE="private/$IMAGE_NAME"
        PUBLIC_IMAGE="library/$IMAGE_NAME"
        PER_ARCH_IMAGE=$([ "$VISIBILITY" = "public" ] && echo "$PUBLIC_IMAGE" || echo "$PRIVATE_IMAGE")

        read -r -a OPT_ARR <<< "${OPTIONS_RAW}"
        mapfile -t EXTRA_ARGS < <(printf '%s\n' "$BUILD_ARGS_RAW" | sed -E 's/#.*$//' | awk 'NF')

        # Parse tags (space or newline separated)
        TAGS_EXTRA=()
        while IFS= read -r line; do
          for t in $line; do [ -n "$t" ] && TAGS_EXTRA+=("$t"); done
        done < <(printf '%s\n' "$TAG_RAW")

        begin "buildx: context"
        [ "$VERBOSE" = "true" ] && {
          echo "registry=$REGISTRY"
          echo "image_name=$IMAGE_NAME"
          echo "visibility=$VISIBILITY"
          echo "per_arch_image=$PER_ARCH_IMAGE"
          echo "arches=$ARCHES"
          echo "dockerfile=$DOCKERFILE"
          echo "context=$CONTEXT"
          echo "push=$PUSH  manifest=$MAKE_MANIFEST"
          echo "tags(extra)=${TAGS_EXTRA[*]:-<none>}"
        }
        end

        BUILT_TAGS=()
        for ARCH in $ARCHES; do
          TAG="$REGISTRY/$PER_ARCH_IMAGE:${GITHUB_SHA}-$ARCH"
          CMD=( docker buildx build --platform "linux/$ARCH" --file "$DOCKERFILE" --tag "$TAG" )
          for BA in "${EXTRA_ARGS[@]}"; do
            CMD+=( --build-arg "${BA//\{arch\}/$ARCH}" )
          done
          [ ${#OPT_ARR[@]} -gt 0 ] && CMD+=( "${OPT_ARR[@]}" )
          [ "$PUSH" = "true" ] && CMD+=( --output type=image,push=true )
          CMD+=( "$CONTEXT" )
          echo ">> ${CMD[*]}"
          "${CMD[@]}"
          BUILT_TAGS+=( "$TAG" )
        done

        {
          echo "built_tags<<EOF"
          printf "%s\n" "${BUILT_TAGS[@]}"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

        # Manifest
        if [ "$MAKE_MANIFEST" != "true" ]; then
          echo "Manifest generation disabled (manifest=false)."; exit 0; fi
        if [ "$PUSH" != "true" ]; then
          echo "::warning::Per-arch images were not pushed (push=false); skipping manifest."; exit 0; fi

        SOURCES=()
        for t in "${BUILT_TAGS[@]}"; do
          docker buildx imagetools inspect "$t" >/dev/null 2>&1 && SOURCES+=( "$t" ) || echo "::warning::Missing source, skip: $t"
        done
        [ ${#SOURCES[@]} -gt 0 ] || { echo "::error::No per-arch sources found for manifest."; exit 1; }

        TARGET_IMAGES=()
        { [ "$VISIBILITY" = "private" ] || [ "$VISIBILITY" = "both" ]; } && TARGET_IMAGES+=( "$PRIVATE_IMAGE" )
        { [ "$VISIBILITY" = "public" ]  || [ "$VISIBILITY" = "both" ]; } && TARGET_IMAGES+=( "$PUBLIC_IMAGE" )

        TAGS_ARGS=()
        for NAME in "${TARGET_IMAGES[@]}"; do
          TAGS_ARGS+=( --tag "$REGISTRY/$NAME:${GITHUB_SHA}" )
          for T in "${TAGS_EXTRA[@]}"; do
            TAGS_ARGS+=( --tag "$REGISTRY/$NAME:$T" )
          done
        done

        echo ">> docker buildx imagetools create ${TAGS_ARGS[*]} ${SOURCES[*]}"
        docker buildx imagetools create "${TAGS_ARGS[@]}" "${SOURCES[@]}"
