name: "Persist (save/restore) files to host store"
description: "Save/restore selected files to a persistent host store by project, preserving structure"

inputs:
  mode:
    description: "save | restore"
    required: true
  files:
    description: "Multiline list of files/dirs or globs (workspace-relative). Comments (# ...) and blank lines allowed."
    required: true
  store:
    description: "Absolute host path bind-mounted in jobs (e.g. /store)"
    required: false
    default: "/store"
  scope:
    description: "Scope: 'global', 'branch', or 'run' (adds a folder level)"
    required: false
    default: "run"
  link:
    description: "When restoring: 'soft' (symlink) or 'hard' (hardlink, copy fallback across devices)"
    required: false
    default: "soft"
  verbose:
    description: "Emit detailed logs (sizes, counts, listings, rsync stats)"
    required: true
    default: "false"
  trace:
    description: "Enable shell tracing (set -x)"
    required: false
    default: "false"
  dry-run:
    description: "Don't write, just report what would happen"
    required: false
    default: "false"

outputs:
  dest_root:
    description: "Resolved root destination in the store"
    value: ${{ steps.run.outputs.dest_root }}

runs:
  using: "composite"
  steps:
    - id: run
      shell: bash
      run: |
        set -euo pipefail

        # Output helper (supports both new and old runners)
        write_output() {
          local k="$1" v="$2"
          if [ -n "${GITHUB_OUTPUT:-}" ]; then
            echo "$k=$v" >> "$GITHUB_OUTPUT"
          else
            echo "::set-output name=$k::$v"
          fi
        }

        MODE="${{ inputs.mode }}"
        STORE="${{ inputs.store }}"
        SCOPE="${{ inputs.scope }}"
        LINK_MODE="${{ inputs.link }}"
        VERBOSE="${{ inputs.verbose }}"
        TRACE="${{ inputs.trace }}"
        DRY_RUN="${{ inputs['dry-run'] }}"
        FILES_RAW="${{ inputs.files }}"

        [ "$TRACE" = "true" ] && set -x || true
        begin(){ [ "$VERBOSE" = "true" ] && echo "::group::$*"; }
        end(){   [ "$VERBOSE" = "true" ] && echo "::endgroup::"; }

        # ensure store mounted & writable
        if [ ! -d "$STORE" ]; then
          echo "::error::Store not mounted: $STORE"
          echo "Hint: mount via runner config, e.g. container.options: -v /data/act_runner/store:/store:rw,z"
          exit 1
        fi
        if ! ( : > "$STORE/.write_test" 2>/dev/null ); then
          echo "::error::Store is not writable by this job: $STORE"
          exit 1
        else
          rm -f "$STORE/.write_test" || true
        fi

        # repo name: org/repo -> org__repo
        REPO_SAFE="${GITHUB_REPOSITORY//\//__}"
        case "$SCOPE" in
          global )  SCOPE_PART="";;
          branch )  SCOPE_PART="/${GITHUB_REF_NAME}";;
          run )     SCOPE_PART="/run-${GITHUB_RUN_ID}";;
          * )       echo "::error::Unknown scope '${SCOPE}' (use 'global', 'branch', or 'run')"; exit 2;;
        esac
        DEST_ROOT="${STORE}/${REPO_SAFE}${SCOPE_PART}"
        write_output dest_root "$DEST_ROOT"

        # parse file list (strip comments & blanks)
        mapfile -t PATTERNS < <(printf '%s\n' "$FILES_RAW" | sed -E 's/#.*$//' | awk 'NF')
        [ "${#PATTERNS[@]}" -gt 0 ] || { echo "::error::No files specified"; exit 2; }

        # glob behavior
        shopt -s nullglob dotglob globstar

        list_dir () {
          local p="$1"
          if [ "$VERBOSE" = "true" ]; then
            if [ -d "$p" ]; then
              echo "path: $p"
              du -sh "$p" 2>/dev/null || true
              echo "files: $(find "$p" -type f | wc -l | tr -d ' ')"
              echo "dirs:  $(find "$p" -type d | wc -l | tr -d ' ')"
              ls -la "$p" | sed -n '1,100p' || true
            elif [ -e "$p" ]; then
              echo "path: $p (file)"; ls -la "$p" || true
            else
              echo "path: $p (missing)"
            fi
          fi
        }

        begin "persist: context"
        echo "mode=$MODE  repo=$REPO_SAFE  scope=${SCOPE:-<none>}  link=${LINK_MODE:-soft}"
        echo "store=$STORE"
        echo "dest_root=$DEST_ROOT"
        echo "workspace=${GITHUB_WORKSPACE:-$PWD}"
        [ "$VERBOSE" = "true" ] && df -h "$STORE" || true
        end

        case "$MODE" in
          save)
            begin "persist: resolve & copy (save)"
            SAVED=()
            for pat in "${PATTERNS[@]}"; do
              case "$pat" in /*|*'..'* ) echo "::error::Invalid pattern (absolute or '..'): $pat"; exit 2;; esac
              matches=( $pat )
              if [ ${#matches[@]} -eq 0 ]; then
                echo "::warning::No matches for pattern: $pat"; continue
              fi
              for m in "${matches[@]}"; do
                dst="$DEST_ROOT/$m"
                if [ -d "$m" ]; then
                  mkdir -p "$dst"
                  if command -v rsync >/dev/null 2>&1; then
                    RSYNC_FLAGS=(-a --delete)
                    [ "$VERBOSE" = "true" ] && RSYNC_FLAGS+=(--stats --info=flist2,progress2)
                    [ "$DRY_RUN" = "true" ] && RSYNC_FLAGS+=(-n)
                    echo "rsync ${RSYNC_FLAGS[*]} $m/. -> $dst/"
                    rsync "${RSYNC_FLAGS[@]}" "$m/." "$dst/"
                  else
                    if [ "$DRY_RUN" = "true" ]; then
                      echo "(dry-run) would wipe '$dst' and cp -a '$m/.' -> '$dst/'"
                    else
                      find "$dst" -mindepth 1 -maxdepth 1 -exec rm -rf {} + 2>/dev/null || true
                      cp -a "$m/." "$dst/"
                    fi
                  fi
                else
                  mkdir -p "$(dirname "$dst")"
                  if [ "$DRY_RUN" = "true" ]; then
                    echo "(dry-run) would cp -a '$m' -> '$dst'"
                  else
                    cp -a "$m" "$dst"
                  fi
                fi
                SAVED+=("$m -> $dst")
                [ "$VERBOSE" = "true" ] && list_dir "$dst"
              done
            done
            [ "$VERBOSE" = "true" ] && { echo "saved items:"; for s in "${SAVED[@]}"; do echo " - $s"; done; }
            end
            ;;

          restore)
            case "$LINK_MODE" in
              soft|symlink)
                begin "persist: restore (soft links / symlinks)"
                RESTORED=()
                for pat in "${PATTERNS[@]}"; do
                  store_matches=( "$DEST_ROOT"/$pat )
                  [ ${#store_matches[@]} -gt 0 ] || { echo "::warning::Nothing saved for $pat"; continue; }
                  for sm in "${store_matches[@]}"; do
                    rel="${sm#$DEST_ROOT/}"
                    case "$rel" in /*|*'..'* ) echo "::error::Invalid stored rel path: $rel"; exit 2;; esac
                    mkdir -p "$(dirname "$rel")"
                    if [ "$DRY_RUN" = "true" ]; then
                      echo "(dry-run) would symlink '$rel' -> '$sm'"
                    else
                      [ -e "$rel" ] || [ -L "$rel" ] && rm -rf "$rel"
                      ln -sfn "$sm" "$rel"
                      echo "link: $rel -> $(readlink "$rel" || true)"
                      [ "$VERBOSE" = "true" ] && list_dir "$rel"
                    fi
                    RESTORED+=("$rel -> $sm")
                  done
                done
                [ "$VERBOSE" = "true" ] && { echo "restored links:"; for r in "${RESTORED[@]}"; do echo " - $r"; done; }
                end
                ;;
              hard)
                begin "persist: restore (hard links; copy fallback if cross-device)"
                RESTORED=()
                for pat in "${PATTERNS[@]}"; do
                  store_matches=( "$DEST_ROOT"/$pat )
                  [ ${#store_matches[@]} -gt 0 ] || { echo "::warning::Nothing saved for $pat"; continue; }
                  for sm in "${store_matches[@]}"; do
                    rel="${sm#$DEST_ROOT/}"
                    case "$rel" in /*|*'..'* ) echo "::error::Invalid stored rel path: $rel"; exit 2;; esac
                    if [ "$DRY_RUN" = "true" ]; then
                      echo "(dry-run) would hardlink/copy '$sm' -> '$rel'"; continue
                    fi
                    [ -e "$rel" ] || [ -L "$rel" ] && rm -rf "$rel"
                    if [ -d "$sm" ]; then
                      mkdir -p "$rel"
                      if cp -al "$sm/." "$rel/" 2>/dev/null; then
                        :
                      else
                        echo "::warning::Hardlink across devices not possible; copying: $sm -> $rel"
                        if command -v rsync >/dev/null 2>&1; then
                          rsync -a --delete "$sm/." "$rel/"
                        else
                          rm -rf "$rel" && mkdir -p "$rel"
                          cp -a "$sm/." "$rel/"
                        fi
                      fi
                    else
                      mkdir -p "$(dirname "$rel")"
                      if ! ln "$sm" "$rel" 2>/dev/null; then
                        echo "::warning::Hardlink failed (likely EXDEV); copying: $sm -> $rel"
                        cp -a "$sm" "$rel"
                      fi
                    fi
                    RESTORED+=("$sm -> $rel")
                    [ "$VERBOSE" = "true" ] && list_dir "$rel"
                  done
                done
                [ "$VERBOSE" = "true" ] && { echo "hardlinked/materialized items:"; for r in "${RESTORED[@]}"; do echo " - $r"; done; }
                end
                ;;
              *)
                echo "::error::Unknown link mode: $LINK_MODE (use 'soft' or 'hard')"; exit 2;;
            esac
            ;;

          *)
            echo "::error::Unknown mode: $MODE"; exit 2;;
        esac
