name: "Fetch release assets by tag"
description: "Download Gitea release assets for a given tag into a folder"

inputs:
  token:
    description: "Gitea token with repo read access"
    required: true
  tag:
    description: "Release tag (e.g. v1.2.3). Defaults to ref_name when run on tag"
    required: false
  owner:
    description: "Repo owner/org (defaults to context)"
    required: false
  repo:
    description: "Repo name (defaults to context)"
    required: false
  api-base:
    description: "Gitea API base URL"
    default: "https://gitea.slope.es/api/v1"
  dest:
    description: "Destination directory for downloaded assets"
    default: "assets"
  pattern:
    description: "Regex to filter asset names (optional)"
    required: false
  fail-if-empty:
    description: "Fail if no assets found"
    default: "true"

outputs:
  count:
    description: "Number of assets downloaded"
    value: ${{ steps.fetch.outputs.count }}
  files_json:
    description: "JSON array of absolute file paths"
    value: ${{ steps.fetch.outputs.files_json }}
  dest:
    description: "Destination directory"
    value: ${{ steps.fetch.outputs.dest }}

runs:
  using: "composite"
  steps:
    - name: Ensure jq (portable)
      shell: bash
      run: |
        set -euo pipefail
        if command -v jq >/dev/null 2>&1; then
          echo "jq already present: $(command -v jq)"
          exit 0
        fi
        BIN_DIR="${GITHUB_WORKSPACE}/.bin"
        mkdir -p "$BIN_DIR"
        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64|amd64)  JQ_URL="https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" ;;
          aarch64|arm64) JQ_URL="https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" ;;
          *) echo "Unsupported arch for auto-jq: $ARCH"; exit 1 ;;
        esac
        curl -fsSL "$JQ_URL" -o "${BIN_DIR}/jq"
        chmod +x "${BIN_DIR}/jq"
        echo "${BIN_DIR}" >> "$GITHUB_PATH"
        jq --version

    - name: Fetch assets
      id: fetch
      shell: bash
      env:
        API_BASE: ${{ inputs['api-base'] }}
        TOKEN: ${{ inputs.token }}
        TAG: ${{ inputs.tag }}
        DEST: ${{ inputs.dest }}
        PATTERN: ${{ inputs.pattern }}
        FAIL_EMPTY: ${{ inputs['fail-if-empty'] }}
        OWNER_IN: ${{ inputs.owner }}
        REPO_IN: ${{ inputs.repo }}
      run: |
        set -euo pipefail

        if [[ -z "${TOKEN:-}" ]]; then
          echo "::error::'token' input is required"; exit 1
        fi

        # Owner/repo: default from context if not provided
        OWNER="${OWNER_IN:-${GITHUB_REPOSITORY%/*}}"
        REPO="${REPO_IN:-${GITHUB_REPOSITORY#*/}}"
        TAG="${TAG:-${GITHUB_REF_NAME:-}}"
        API="${API_BASE%/}"

        if [[ -z "$OWNER" || -z "$REPO" || -z "$TAG" ]]; then
          echo "::error::owner/repo/tag missing. owner='${OWNER}' repo='${REPO}' tag='${TAG}'"; exit 1
        fi

        echo "Repo: ${OWNER}/${REPO}"
        echo "Tag:  ${TAG}"
        echo "API:  ${API}"

        mkdir -p "$DEST"

        # small helpers
        req() {  # curl that prints status to stdout, writes body to file if arg2 present
          local url="$1"; local out="${2:-}"
          local code
          if [[ -n "$out" ]]; then
            code=$(curl -sS -L -w '%{http_code}' -o "$out" \
                    -H "Authorization: token ${TOKEN}" "$url")
          else
            code=$(curl -sS -L -w '%{http_code}' \
                    -H "Authorization: token ${TOKEN}" "$url")
          fi
          echo -n "$code"
        }

        not_binary_json_or_html() {  # returns 0 if looks like JSON/HTML; 1 otherwise
          local f="$1"
          local head
          head=$(head -c 16 "$f" || true)
          [[ "$head" =~ ^\{ || "$head" =~ ^\< || "$head" =~ ^\"?\{ ]]
        }

        looks_like_elf() {  # returns 0 if ELF magic 0x7f454c46
          local f="$1"
          local magic
          magic=$(head -c 4 "$f" | od -An -t x1 | tr -d ' \n')
          [[ "$magic" == "7f454c46" ]]
        }

        # 1) get release by tag
        rel_json="$(curl -fsSL -H "Authorization: token ${TOKEN}" \
          "${API}/repos/${OWNER}/${REPO}/releases/tags/${TAG}")" || {
            echo "::error::Failed to fetch release for tag ${TAG}"; exit 1; }

        rel_id="$(jq -r '.id' <<<"$rel_json")"
        if [[ -z "$rel_id" || "$rel_id" == "null" ]]; then
          echo "::error::Release not found for tag ${TAG}"; exit 1
        fi

        # 2) list assets
        assets_json="$(curl -fsSL -H "Authorization: token ${TOKEN}" \
          "${API}/repos/${OWNER}/${REPO}/releases/${rel_id}/assets")"

        # optional filter by regex
        if [[ -n "${PATTERN:-}" ]]; then
          assets_json="$(jq --arg re "$PATTERN" '[ .[] | select(.name|test($re)) ]' <<<"$assets_json")"
        fi

        count="$(jq 'length' <<<"$assets_json")"
        echo "Found ${count} assets after filtering"
        if [[ "$count" -eq 0 ]]; then
          if [[ "${FAIL_EMPTY,,}" == "true" ]]; then
            echo "::error::No assets to download"; exit 2
          else
            echo "No assets to download (continuing)."
            {
              echo "count=0"
              echo "files_json=[]"
              echo "dest=${DEST}"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        files=()
        while IFS= read -r row; do
          id="$(jq -r '.id'   <<<"$row")"
          name="$(jq -r '.name' <<<"$row")"
          bdl="$(jq -r '.browser_download_url // empty' <<<"$row")"

          echo "Downloading: ${name}"
          target="${DEST}/${name}"
          ok=0

          # Prefer browser_download_url (some Gitea versions handle this best)
          if [[ -n "$bdl" ]]; then
            code=$(req "$bdl" "$target")
            [[ "$code" == "200" ]] && ok=1

            # If header auth not honored across redirects, try query token
            if [[ "$ok" -eq 0 ]]; then
              sep='?'; [[ "$bdl" == *\?* ]] && sep='&'
              code=$(req "${bdl}${sep}access_token=${TOKEN}" "$target")
              [[ "$code" == "200" ]] && ok=1
            fi
          fi

          # Fallback to API endpoint with octet-stream
          if [[ "$ok" -eq 0 ]]; then
            code=$(curl -sS -L -w '%{http_code}' -o "$target" \
                      -H "Authorization: token ${TOKEN}" \
                      -H "Accept: application/octet-stream" \
                      "${API}/repos/${OWNER}/${REPO}/releases/${rel_id}/assets/${id}")
            [[ "$code" == "200" ]] && ok=1
          fi

          if [[ "$ok" -ne 1 ]]; then
            echo "::error::Failed to download ${name} (HTTP ${code})"
            exit 3
          fi

          # Guard: reject JSON/HTML error bodies early
          if not_binary_json_or_html "$target"; then
            echo "::error::Downloaded ${name} looks like JSON/HTML (not a binary)."
            echo "First bytes:"; head -c 120 "$target" || true; echo
            exit 4
          fi

          # Optional: enforce ELF for typical Linux binaries (skip if you also fetch zips)
          case "$name" in
            *.zip|*.tar|*.tar.gz|*.tgz) : ;; # archives allowed
            *)
              if ! looks_like_elf "$target"; then
                echo "::warning::${name} does not look like an ELF binary. File says:"
                file "$target" || true
              fi
              ;;
          esac

          chmod +x "$target" || true
          files+=("$target")
        done < <(jq -c '.[]' <<<"$assets_json")

        files_json="$(printf '%s\n' "${files[@]}" | jq -R . | jq -s -c '.')"
        echo "Downloaded files:"
        echo "${files_json}"

        {
          echo "count=${count}"
          echo "files_json=${files_json}"   # compact single-line JSON
          echo "dest=${DEST}"
        } >> "$GITHUB_OUTPUT"
